<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FLOWnomics Calculator</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babel-standalone@7.22.9/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState } = React;

        function formatNumber(value) {
            return new Intl.NumberFormat('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(value);
        }

        function parseInput(value) {
            if (!value) return 0;
            return parseFloat(value.replace(/,/g, '')) || 0;
        }

        function FLOWnomicsCalculator() {
            // State for inputs
            const [settlementVolumeType, setSettlementVolumeType] = useState('total');
            const [asv, setAsv] = useState('');
            const [asvGrowthRate, setAsvGrowthRate] = useState('');
            const [velocity, setVelocity] = useState('');
            const [velocityChangeRate, setVelocityChangeRate] = useState('');
            const [forecastHorizon, setForecastHorizon] = useState('');
            const [totalSupply, setTotalSupply] = useState('');
            const [lockedSupplyPercent, setLockedSupplyPercent] = useState('');
            const [additionalLockedSupply, setAdditionalLockedSupply] = useState('');
            const [yearlyBurnRate, setYearlyBurnRate] = useState('');
            const [useBurnRate, setUseBurnRate] = useState(false);
            const [liquidityBuffer, setLiquidityBuffer] = useState('');
            const [useLiquidityBuffer, setUseLiquidityBuffer] = useState(false);
            const [currentPrice, setCurrentPrice] = useState('');
            // Assumptions for metrics requiring additional data
            const [activeWallets] = useState(1000000); // Placeholder
            const [totalGasUsed] = useState(1000000); // Placeholder
            const [marketDepth] = useState(1000000000); // Placeholder
            const [slippageThreshold] = useState(0.01); // Placeholder
            const [velocityStdDev] = useState(0.5); // Placeholder
            const [maxTransactionCapacity] = useState(1000000000000); // Placeholder
            const [volatility] = useState(0.3); // Placeholder
            const [flowStdDev30] = useState(1000000000); // Placeholder
            const [flowStdDev90] = useState(1500000000); // Placeholder
            const [marketReturn] = useState(0.1); // Placeholder
            const [cryptoMarketCorrelation] = useState(0.7); // Placeholder
            const [avgTxConfirmationTime] = useState(2); // Placeholder
            const [industryBenchmark] = useState(5); // Placeholder
            const [walletGrowthRate] = useState(0.2); // Placeholder
            const [giniCoefficient] = useState(0.4); // Placeholder

            // Parse inputs
            const parsedASV = parseInput(asv);
            const parsedASVGrowthRate = parseInput(asvGrowthRate) / 100;
            const parsedVelocity = parseInput(velocity) || 1; // Avoid division by zero
            const parsedVelocityChangeRate = parseInput(velocityChangeRate) / 100;
            const parsedForecastHorizon = parseInput(forecastHorizon) || 5;
            const parsedTotalSupply = parseInput(totalSupply);
            const parsedLockedSupplyPercent = parseInput(lockedSupplyPercent) / 100;
            const parsedAdditionalLockedSupply = parseInput(additionalLockedSupply) / 100;
            const parsedYearlyBurnRate = parseInput(yearlyBurnRate);
            const parsedLiquidityBuffer = parseInput(liquidityBuffer) / 100;
            const parsedCurrentPrice = parseInput(currentPrice);

            // Calculations
            const effectiveSupply = parsedTotalSupply * (1 - parsedLockedSupplyPercent);
            const marketCap = effectiveSupply * parsedCurrentPrice;
            const flow = parsedASV / parsedVelocity;
            const adjustedFlow = flow * (1 + (useLiquidityBuffer ? parsedLiquidityBuffer : 0));
            const impliedPrice = adjustedFlow / effectiveSupply;
            const fairMarketGap = ((impliedPrice - parsedCurrentPrice) / parsedCurrentPrice) * 100;
            const flowToPriceRatio = flow / (parsedCurrentPrice * effectiveSupply);
            const flowPremium = ((marketCap - adjustedFlow) / adjustedFlow) * 100;
            const flowYield = flow / marketCap;
            const flowEfficiency = parsedASV / marketCap;
            const settlementElasticity = parsedASVGrowthRate / (marketCap ? 0.01 : 1); // Simplified
            const effectiveVsNominalVelocity = parsedVelocity / (parsedVelocity + 0.1); // Simplified
            const utilizationRate = parsedASV / adjustedFlow;
            const gasEfficiencyIndex = parsedASV / totalGasUsed;
            const settlementPerWallet = parsedASV / activeWallets;
            const activeUserConcentration = giniCoefficient;
            const liquidityStressBufferRatio = (parsedLiquidityBuffer * flow) / marketCap;
            const priceStabilityVelocityDrop = (adjustedFlow / (effectiveSupply * (parsedVelocity * 0.9))) / impliedPrice;
            const burnAdjustedSupply = effectiveSupply - (useBurnRate ? parsedYearlyBurnRate : 0);
            const burnAmplificationFactor = (adjustedFlow / burnAdjustedSupply) / impliedPrice;
            const lockupFlexImpact = (adjustedFlow / (effectiveSupply * (1 - parsedAdditionalLockedSupply))) / impliedPrice;
            const liquidityDepthRatio = marketDepth / parsedASV;
            const velocityStabilityIndex = velocityStdDev / parsedVelocity;
            const networkCongestionResistance = maxTransactionCapacity / parsedASV;
            const speculativeVolatilityBuffer = (parsedLiquidityBuffer * marketCap) / (parsedASV * volatility);
            const futureSupplyAdjustmentFactor = (effectiveSupply * (1 - parsedAdditionalLockedSupply)) / effectiveSupply;
            const flowVolatility30 = flowStdDev30 / flow;
            const flowVolatility90 = flowStdDev90 / flow;
            const annualFlowReturn = (flow / marketCap) - 1; // Simplified
            const annualizedFlowReturnVsMarket = annualFlowReturn / marketReturn;
            const impliedDownsideASVDrop = (adjustedFlow / (effectiveSupply * (parsedASV * 0.8))) / impliedPrice;
            const impliedUpsideVelocityHalf = (adjustedFlow / (effectiveSupply * (parsedVelocity * 0.5))) / impliedPrice;
            const marketCorrelationRisk = cryptoMarketCorrelation;
            const projectedASV = parsedASV * Math.pow(1 + parsedASVGrowthRate, parsedForecastHorizon);
            const projectedVelocity = parsedVelocity * Math.pow(1 + parsedVelocityChangeRate, parsedForecastHorizon);
            const projectedSupply = effectiveSupply * (1 - parsedAdditionalLockedSupply);
            const futurePrice = (projectedASV / projectedVelocity) / projectedSupply;
            const cagrFlowPrice = (futurePrice / parsedCurrentPrice) ** (1 / parsedForecastHorizon) - 1;
            const asvGrowthSensitivity = parsedASVGrowthRate / 0.01; // Simplified
            const velocityDeclineSensitivity = (-parsedVelocityChangeRate) / 0.01; // Simplified
            const maxLockupStressTest = adjustedFlow / (effectiveSupply * 0.1);
            const fairMarketGapBear = ((adjustedFlow / (effectiveSupply * (parsedASV * 0.8))) - parsedCurrentPrice) / parsedCurrentPrice * 100;
            const fairMarketGapBull = ((adjustedFlow / (effectiveSupply * (parsedASV * 1.2))) - parsedCurrentPrice) / parsedCurrentPrice * 100;
            const futureLiquiditySufficiencyRatio = (marketCap / adjustedFlow) * (projectedASV / parsedASV);
            const settlementCoverageRatio = parsedASV / (effectiveSupply * parsedCurrentPrice);
            const theoreticalFlow = flow; // Simplified
            const realizedVsTheoreticalFlow = parsedASV / (theoreticalFlow * parsedVelocity);
            const transactionLatencyIndex = avgTxConfirmationTime / industryBenchmark;
            const userAdoptionRate = walletGrowthRate;
            const operationalScalabilityScore = projectedASV / parsedASV;

            // Input fields configuration
            const inputs = [
                { label: 'Settlement Volume Type', type: 'select', value: settlementVolumeType, setValue: setSettlementVolumeType, options: ['total', 'onchain'], id: 'settlementVolumeType' },
                { label: 'Annual Settlement Volume ($ ASV)', type: 'text', value: asv, setValue: setAsv, placeholder: 'e.g., 500,000,000,000' },
                { label: 'ASV Growth Rate (% per year)', type: 'text', value: asvGrowthRate, setValue: setAsvGrowthRate, placeholder: 'e.g., 5' },
                { label: 'Velocity (times per year)', type: 'text', value: velocity, setValue: setVelocity, placeholder: 'e.g., 10' },
                { label: 'Velocity Change Rate (% per year)', type: 'text', value: velocityChangeRate, setValue: setVelocityChangeRate, placeholder: 'e.g., 2' },
                { label: 'Forecast Horizon (years)', type: 'text', value: forecastHorizon, setValue: setForecastHorizon, placeholder: 'e.g., 5' },
                { label: 'Total Circulating Supply (tokens)', type: 'text', value: totalSupply, setValue: setTotalSupply, placeholder: 'e.g., 100,000,000,000' },
                { label: 'Locked Supply Percentage (%)', type: 'text', value: lockedSupplyPercent, setValue: setLockedSupplyPercent, placeholder: 'e.g., 20' },
                { label: 'Additional Locked Supply Next Year (%)', type: 'text', value: additionalLockedSupply, setValue: setAdditionalLockedSupply, placeholder: 'e.g., 5' },
                { label: 'Yearly Burn Rate (tokens)', type: 'text', value: yearlyBurnRate, setValue: setYearlyBurnRate, placeholder: 'e.g., 1,000,000,000' },
                { label: 'Use Burn Rate', type: 'checkbox', value: useBurnRate, setValue: setUseBurnRate },
                { label: 'Liquidity Buffer Ratio (%)', type: 'text', value: liquidityBuffer, setValue: setLiquidityBuffer, placeholder: 'e.g., 20' },
                { label: 'Use Liquidity Buffer', type: 'checkbox', value: useLiquidityBuffer, setValue: setUseLiquidityBuffer },
                { label: 'Current Market Price ($)', type: 'text', value: currentPrice, setValue: setCurrentPrice, placeholder: 'e.g., 3.60' },
            ];

            // Results configuration
            const results = [
                {
                    title: 'Core Valuation Metrics',
                    metrics: [
                        { label: 'Current Effective Circulating Supply', value: formatNumber(effectiveSupply), description: 'Total supply adjusted for locked tokens.' },
                        { label: 'Current Market Capitalization', value: `$${formatNumber(marketCap)}`, description: 'Effective supply × current market price.' },
                        { label: 'FLOW (Economic Base)', value: `$${formatNumber(flow)}`, description: 'ASV ÷ Velocity, the economic base needed to support transactions.' },
                        { label: 'Adjusted FLOW (with buffer)', value: `$${formatNumber(adjustedFlow)}`, description: 'FLOW × (1 + Liquidity Buffer), adjusted for market stability.' },
                        { label: 'Implied Price per Token', value: `$${formatNumber(impliedPrice)}`, description: 'Adjusted FLOW ÷ Effective Supply, the fair price based on utility.' },
                        { label: 'Fair Market Gap (%)', value: `${formatNumber(fairMarketGap)}%`, description: 'Percentage price increase needed to match FLOW’s fair value.' },
                        { label: 'FLOW-to-Price Ratio', value: formatNumber(flowToPriceRatio), description: 'FLOW ÷ (Market Price × Effective Supply). Above 1 means fair utility price is higher than current.' },
                        { label: 'FLOW Premium (%)', value: `${formatNumber(flowPremium)}%`, description: '(Market Cap − Adjusted FLOW) ÷ Adjusted FLOW × 100%. Positive means undervalued.' },
                    ],
                },
                {
                    title: 'Efficiency & Utility Metrics',
                    metrics: [
                        { label: 'FLOW Yield', value: formatNumber(flowYield), description: 'FLOW ÷ Market Cap. Higher values indicate more liquidity support per dollar of market cap.' },
                        { label: 'FLOW Efficiency', value: formatNumber(flowEfficiency), description: 'ASV ÷ Market Cap. Higher values show more settlement volume per dollar of market cap.' },
                        { label: 'Settlement Elasticity', value: formatNumber(settlementElasticity), description: 'Evaluates ASV response to market cap changes.' },
                        { label: 'Effective vs. Nominal Velocity', value: formatNumber(effectiveVsNominalVelocity), description: 'Compares actual to theoretical token usage.' },
                        { label: 'Utilization Rate', value: formatNumber(utilizationRate), description: 'ASV ÷ Adjusted FLOW. Measures how fully the economic base is utilized.' },
                        { label: 'Gas Efficiency Index', value: formatNumber(gasEfficiencyIndex), description: 'ASV ÷ Total Gas Used. Measures value per unit of transaction cost.' },
                        { label: 'Settlement per Wallet', value: formatNumber(settlementPerWallet), description: 'ASV ÷ Active Wallets. Gauges value per user.' },
                        { label: 'Active User Concentration (Gini)', value: formatNumber(activeUserConcentration), description: 'Assesses distribution of usage.' },
                    ],
                },
                {
                    title: 'Liquidity & Stability Metrics',
                    metrics: [
                        { label: 'Liquidity Stress Buffer Ratio', value: formatNumber(liquidityStressBufferRatio), description: '(Liquidity Buffer × FLOW) ÷ Market Cap. Assesses liquidity reserves.' },
                        { label: 'Slippage Resilience Score', value: formatNumber(marketDepth / (parsedASV + slippageThreshold)), description: 'Market Depth ÷ (ASV + Slippage Threshold). Assesses resistance to large trades.' },
                        { label: 'Price Stability under 10% Velocity Drop', value: formatNumber(priceStabilityVelocityDrop), description: 'New Implied Price ÷ Current at Velocity × 0.9.' },
                        { label: 'Burn Amplification Factor', value: formatNumber(burnAmplificationFactor), description: 'New Implied Price after Burn ÷ Current Implied Price.' },
                        { label: 'Lock-up Flex Impact', value: formatNumber(lockupFlexImpact), description: 'New Implied Price with Lock-up ÷ Current Implied Price.' },
                        { label: 'Liquidity Depth Ratio', value: formatNumber(liquidityDepthRatio), description: 'Market Depth ÷ ASV. Measures available liquidity.' },
                        { label: 'Velocity Stability Index', value: formatNumber(velocityStabilityIndex), description: 'Standard deviation of Velocity over 90 days ÷ Average Velocity.' },
                        { label: 'Network Congestion Resistance', value: formatNumber(networkCongestionResistance), description: 'Max Transaction Capacity ÷ ASV. Evaluates capacity under high demand.' },
                        { label: 'Speculative Volatility Buffer', value: formatNumber(speculativeVolatilityBuffer), description: '(Liquidity Buffer × Market Cap) ÷ (ASV × Volatility). Protection against price swings.' },
                        { label: 'Future Supply Adjustment Factor', value: formatNumber(futureSupplyAdjustmentFactor), description: 'Projected Effective Supply ÷ Current Effective Supply.' },
                    ],
                },
                {
                    title: 'Risk & Volatility Metrics',
                    metrics: [
                        { label: '30-day FLOW Volatility', value: formatNumber(flowVolatility30), description: 'Standard deviation of daily FLOW over 30 days.' },
                        { label: '90-day FLOW Volatility', value: formatNumber(flowVolatility90), description: 'Standard deviation of daily FLOW over 90 days.' },
                        { label: 'Annualized FLOW Return vs. Market', value: formatNumber(annualizedFlowReturnVsMarket), description: 'Annual FLOW Return ÷ Market Return.' },
                        { label: 'Implied Downside if ASV Drops 20%', value: formatNumber(impliedDownsideASVDrop), description: 'New Implied Price at ASV × 0.8 ÷ Current.' },
                        { label: 'Implied Upside if Velocity Halves', value: formatNumber(impliedUpsideVelocityHalf), description: 'New Implied Price at Velocity × 0.5 ÷ Current.' },
                        { label: 'Market Correlation Risk', value: formatNumber(marketCorrelationRisk), description: 'Correlation Coefficient of Token Price vs. Crypto Market Index.' },
                    ],
                },
                {
                    title: 'Forecasting & Scenario Metrics',
                    metrics: [
                        { label: `Future Price (in ${parsedForecastHorizon} years)`, value: `$${formatNumber(futurePrice)}`, description: 'Projected ASV ÷ Projected Velocity ÷ Projected Effective Supply.' },
                        { label: '5-year CAGR FLOW Price', value: `${formatNumber(cagrFlowPrice * 100)}%`, description: '(Future Price ÷ Current Price)^(1/5) - 1.' },
                        { label: 'ASV Growth Sensitivity', value: formatNumber(asvGrowthSensitivity), description: '% Δ Implied Price ÷ % Δ ASV.' },
                        { label: 'Velocity Decline Sensitivity', value: formatNumber(velocityDeclineSensitivity), description: '% Δ Implied Price ÷ % Δ Velocity.' },
                        { label: 'Max Lock-up Stress Test', value: formatNumber(maxLockupStressTest), description: 'Adjusted FLOW ÷ Minimum Effective Supply.' },
                        { label: 'Fair Market Gap in Bear Scenario', value: `${formatNumber(fairMarketGapBear)}%`, description: 'Gap in low ASV case.' },
                        { label: 'Fair Market Gap in Bull Scenario', value: `${formatNumber(fairMarketGapBull)}%`, description: 'Gap in high ASV case.' },
                        { label: 'Future Liquidity Sufficiency Ratio', value: formatNumber(futureLiquiditySufficiencyRatio), description: '(Current Market Cap ÷ Projected FLOW) × (Projected ASV ÷ Current ASV).' },
                    ],
                },
                {
                    title: 'Operational Ratios',
                    metrics: [
                        { label: 'Settlement Coverage Ratio', value: formatNumber(settlementCoverageRatio), description: 'ASV ÷ (Effective Supply × Price). Measures transaction coverage.' },
                        { label: 'Realized Settlement vs Theoretical FLOW', value: formatNumber(realizedVsTheoreticalFlow), description: 'ASV ÷ (Theoretical FLOW × Velocity). Validates FLOW model.' },
                        { label: 'Transaction Latency Index', value: formatNumber(transactionLatencyIndex), description: 'Average Transaction Confirmation Time ÷ Industry Benchmark.' },
                        { label: 'User Adoption Rate', value: `${formatNumber(userAdoptionRate * 100)}%`, description: '% Δ Active Wallets ÷ Time Period.' },
                        { label: 'Operational Scalability Score', value: formatNumber(operationalScalabilityScore), description: 'Projected ASV ÷ Current ASV. Assesses readiness for growth.' },
                    ],
                },
            ];

            return (
                <div className="min-h-screen bg-gray-100 p-4">
                    <div className="max-w-4xl mx-auto">
                        <h1 className="text-3xl font-bold text-center mb-6">FLOWnomics Calculator</h1>
                        <p className="text-center mb-8">Calculate the Functional Liquidity Operating Worth Metrics for utility tokens like XRP.</p>
                        
                        {/* Input Form */}
                        <div className="bg-white p-6 rounded-lg shadow-md mb-8">
                            <h2 className="text-2xl font-semibold mb-4">Input Parameters</h2>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {inputs.map((input, index) => (
                                    <div key={index} className="flex flex-col">
                                        <label className="font-medium">{input.label}</label>
                                        {input.type === 'select' ? (
                                            <select
                                                value={input.value}
                                                onChange={(e) => input.setValue(e.target.value)}
                                                className="mt-1 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            >
                                                <option value="total">Total (On-Chain + Off-Chain)</option>
                                                <option value="onchain">On-Chain Only</option>
                                            </select>
                                        ) : input.type === 'checkbox' ? (
                                            <input
                                                type="checkbox"
                                                checked={input.value}
                                                onChange={(e) => input.setValue(e.target.checked)}
                                                className="mt-1 h-5 w-5"
                                            />
                                        ) : (
                                            <input
                                                type="text"
                                                value={input.value}
                                                onChange={(e) => input.setValue(e.target.value)}
                                                placeholder={input.placeholder}
                                                className="mt-1 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            />
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Results */}
                        <div className="bg-white p-6 rounded-lg shadow-md">
                            <h2 className="text-2xl font-semibold mb-4">Results</h2>
                            {results.map((section, index) => (
                                <div key={index} className="mb-6">
                                    <h3 className="text-xl font-semibold mb-2">{section.title}</h3>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        {section.metrics.map((metric, idx) => (
                                            <div key={idx} className="p-4 bg-gray-50 rounded-lg">
                                                <p className="font-medium">{metric.label}: {metric.value}</p>
                                                <p className="text-sm text-gray-600">{metric.description}</p>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>

                        {/* Footer Links */}
                        <div className="mt-8 text-center">
                            <h3 className="text-lg font-semibold mb-4">Explore More FLOWnomics Resources</h3>
                            <p><a href="https://github.com/futurexrp/FLOWnomics" className="text-blue-600 hover:underline">🌐 View the Full FLOWnomics Repository on GitHub</a></p>
                            <p><a href="https://futurexrp.github.io/FLOWnomics/#cheat-sheet" className="text-blue-600 hover:underline">📝 Read the Cheat Sheet & Beginner Guide</a></p>
                            <p className="mt-4 text-gray-600">Created by Matt Blair.</p>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<FLOWnomicsCalculator />, document.getElementById('root'));
    </script>
</body>
</html>
